# アセンブリ言語

`5-insb1.pdf` 30p〜

就職活動の時はtitech.ac.jpはつよい。

間接ジャンプのときは、記法が一貫していないので、`*`を用いる。

`1f` : f: forward 
```assembly
jnz 1f
ljmp *4(%rbp)
1:
```
数値ラベルは、一番最初に見つかった1にいくということ

条件は、基本`zero`かどうかさえ、わかっていれば条件を表現できるが、まぁ色々な命令が用意されているので、使いましょうね

`less, greater`は符号あり、`above, below`は符号なしということだけ覚えておいた方がよい

`jcxz`は、shortジャンプなので、ジャンプ先がかなり制限される。（これ試してみること）

### 実行可能ファイル

この中に、セクションと呼ばれるものが存在する。`.text`,`.data`,`.bss`などがある。

OSは、このファイルをメモリ上にコピーして、エントリーポイントにプログラムカウンタを設定する。

ヒープ領域は、基本的にメモリの動的確保のときに使われる。
ヒープ領域とスタック領域は決して衝突しない。これは、実際に物理的に確保できる領域以上に、アドレス空間が存在するので、衝突する前に、物理的な上限に達する。

`call`命令の次命令のアドレスに帰ってきたいので、プログラムカウンタが指している値をスタックにpushする。（stack上への待避）
(`return`アドレスをスタックに待避する -> 関数に入る -> 戻る値をスタックからpopして、プログラムカウンタにそのreturnアドレスを設定する。 )


ウイルス等は、スタック上に意味のない情報を積んだり、現在スタックトップにあるものを書き換えたり、そう言ったことを行う。

どの関数を呼ぶか実行時までわからない時(:=ポインタとかで関数を指している時)、`*%rax`とかを使う。

p.40

`*(%rax)`にすると、`(%rax)`の値を読んでからになる

c言語の関数ポインタを復習しないと...
`int (*fp) (int n)`: (int n)という引数

式の中で、`add5`が出てきたら暗黙の型変換がおきて、ポインタになる。
(関数は、式中で出たきたら暗黙的にポインタになる。)

間接コール　:= 関数呼び出し（関数ポインタを用いた）(= C言語)

### `enter`命令

gccとかclangは、enter命令を使用しない。代わりにそれぞれをばらしたものを使用する

`time`コマンド
`0.000u 0.000s 0:00:00`
`$ time ./a.out`で測れる

cpu使用時間（u:=user空間でcpuを使用した時間, s:=systemがcpuを使用した時間）、elapsed time(:=本当にプログラムを実行した時間のこと)

※ 実行時間が短いものは、`time`コマンドで測ってはいけない。

timeの代わりに、rdtscという、CPUのタイムスタンプカウンタを使って測る。
でも、これだと、cpuの実行時間の一部が他のソフトウェアに移っている時間があるかもしれないので

`tester, testee` , `debuger, debugee`

レジスタ上にデータ領域が足らなくなったら、スタックへデータを逃す。

レジスタごとに、callerとcalleeどちらの側でデータを待避させるのかが決まっている。
（ABI: Application Binary Interfaceで決まっているのでしょうがない）


`%rsp`: stack pointer

`%rbp`: stack base pointer

この二つは、通常はスタックトップの先頭と、末尾を指している。
各スタックフレームは、連結リストになっている。

スッタックフレームとかその辺りが、いまだにわかっていない。（どうしても名前が覚えきれていない。）

### スタックレイアウト

どのようにスタックフレームにデータを渡すか

`%rax`: 返値

x86-64では、返値が小さいときは、高速性の観点かレジスタを使用して渡すことがある

### calling convention

第1引数から第６引数まではレジスタで渡す


`%rdi`:= 第１引数

### 関数プロローグと関数エピローグ

`pushq`した順と逆に`popq`をする。

現在は、push命令ではなくmove命令で値をレジスタを使用して渡している。