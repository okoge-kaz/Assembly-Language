# アセンブリ言語

### カーネル

入出力装置はとても遅いので（ms単位）、ユーザープロセスからシステムコールをカーネルに発行し、入出力装置が準備できると、割り込みによってカーネルは入出力処理を開始する。

### CISC 
Complex Instruction Set Computer

１つの命令で複雑な処理を行う。直行性が低い（＝色々と例外とか場合によって複雑な条件がある。）

オペランドが２つ（＝スタックから２つ取り出して、演算して戻す。という思想）

なんで、x86-64でCISCなのか？今の時代、RISCの方が性能が出るということはわかっているけど、後方互換性(backward compatibility)の観点から変えられない。

### アドレッシングモード

機械語命令のオペランドに何を書くか

#### 即値

定数(= 生の`$0x1000`という値をとってもいいし、`$_foo`のようなものでもよい)

#### メモリ

- 直接アドレス指定

  `addq 0x100, %rax`: `$`がないので、定数ではない。(`0x100`のはなし)

- 間接アドレス指定
  
  `addq (%rbp), %rax` : `(%rbp)`のアドレスにある値を参照する

### `nop`命令

プログラムカウンタのみ動くが、それ以外は何もしない

RISCのパイプライン処理のとき、遅延分岐スロットを空にしないためとか、まぁいろんなところで使えるよ

### `mov`命令

`mov`命令は、第１オペランドの値を第２オペランドにコピーする。

メモリからメモリへの直接コピーはできない。(重要)

コンパイラが、最も良い方を選んでくれるので、あんまり気に止む必要はない

`.text`セクションに`movq`命令を書くのと、`.byte`で直打ちするのは、アセンブラ的には同じ

### `xchg`

アトミック: 中東半端に書き換えた情報を読まれたり、書き込まれたりしたくないので、書き込む前の状態や、書き込みが完全に終了した状態しか見えない。（これは、応用情報のデータベースの試験ででる。）

`mov`命令はアトミック性は保証されていない。

ページ境界をまたぐと、ページング処理が発生して、そのせいで他のスレッドで実行されているものが、その対象のデータを読み書きしてしまうことがあり得る。

だから、Lockなどのセマフォの概念が必要になる。

### `lea`: load effective address



### 

`mov`命令は64bitをコピーできるものとできないものがあるので、それように`mov〜`という名前がついているときがある。

### `mul`, `div`命令

`mul`: multiply 掛け算

`imulq %rbx`となっているのは、あらかじめ、掛け算を行う前に`%rdx`レジスタに値を瀬戸しておいて演算したりする。（この辺りは、聞き間違えもあると思うので調べる。）

### インクリメント、デクリメント

ただの足し算と違って、インクリメント、デクリメントではCF(キャリーフラグ)は立たない。

### シフト演算

右にシフトするのか、左にシフトするのかで2パターン。
また、算術シフトなのか論理シフトするのかで２パターン。以上で4パターンある。

算術シフトの場合は、MSBに入っていた値(0 or 1)を右シフトのとき入れるが、論理シフトの時はMSBに必ず0をいれる。

このように、右シフトのときだけ、算術シフトと論理シフトの間に差が生じる。

### 比較命令

フラグ計算だけを行うので、メモリの値や、レジスタの値を変化させない。

`cmp`命令は、`sub`(引き算命令)のふりをして、フラグの値の変化だけ行う。

### ジャンプ命令

セグメントをまたがないジャンプをnearジャンプという。また、セグメントをまたぐものはfarジャンプという。

先頭からの位置（何バイトの位置なのか）を指してジャンプ先を指定するのを、絶対ジャンプ

プログラムカウンタの位置から、どれだけずれるのかを指定するのが相対ジャンプ。

メモリと同様に、直接ジャンプ、間接ジャンプという違いもある。


