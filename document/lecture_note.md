# アセンブリ言語

[参考資料](https://www.sigbus.info/compilerbook)

移植性(protability): アセンブリ言語は移植性が低いのが特徴

macOS環境であればとてもよい

環境は macOS gcc(clang) (デバッガ: lldb)

`movq  %rsp, %rbp` は、ニモニック(mnemonic)

`_add5:` は、ラベル

## コンパイル、アセンブル

アセンブラ命令でいらない（すくなくとも今回の授業ではいらないものがあるので`-fno-asynchronous-unwind-tables -fno-verboseasm`をコンパイルオプションを書く）

`add5.o`は、バイナリファイルなので`less`コマンドでは見れない、よって`od -A d -t x1 add5.o `のように`od`コマンドで16進ダンプする必要がある

## ２進数

２進数だけでは、文字なのか機械語命令なのかわからない。これは外部から与えられる。

機械語コード＝プログラムのこと

`od`コマンド : 名前の由来はoctual dump

16進ダンプ = バイナリデータを１バイト毎に16進数で表示すること

- 逆アセンブル
```
objdump -d add5.o                                                                                                                                

add5.o: file format mach-o 64-bit x86-64


Disassembly of section __TEXT,__text:

0000000000000000 <_add5>:
       0: 55                            pushq   %rbp
       1: 48 89 e5                      movq    %rsp, %rbp
       4: 48 89 7d f8                   movq    %rdi, -8(%rbp)
       8: 48 8b 45 f8                   movq    -8(%rbp), %rax
       c: 48 83 c0 05                   addq    $5, %rax
      10: 5d                            popq    %rbp
      11: c3                            retq

```

テキストセクションの先頭からのバイト数が左側に書かれる。

x86-64の命令は、命令によって長さがバラバラ（可変長）

## ABI API

- コーリングコンベンション ( = 関数呼び出し規約)

ABIは、バイナリファイルを再コンパイルなしに実行できる

APIは、ソースコードのためのインタフェース

再コンパイルすれば同じソースコードを実行できる。

## `add5.s`早わかり

`.text` などの`.`で始まるのはアセンブラ命令

ドル記号$ は定数（即値）

% パーセント記号は、レジスタ

コロン記号 : で終わるのはラベル

naive: 素朴な愚直な という意味でコンピューターサイエンスでは用いる。

C/C++からアセンブリ言語にコンパイルするときは、さまざまなアセンブリ言語の書き方が考えられるが、アセンブルするときに実行ファイルになるときはほぼ一意に決まる。

モジュール分割が不適切だと、保守性が悪化する。よくある例だと、修正するのに同じようなプログラミングを修正する羽目になる。

プログラムを作るときは、なんとなくの予想に基づいてモジュール分割を行うが往々にして、あとで見直す羽目になる。

- バイナリ形式
スライドに存在するような様々なバイナリ形式すべてに対して使うことが可能

- tarage(ターゲット)
どうして、プログラムを実行するプラットフォームが重要か？というと、プログラムを作成するOSとそれを実行するOSが異なることは往々にしてあるから（＝クロスコンパイル）

例. iosアプリケーション

- リンク
複数のオブジェクトファイルをリンクして実行可能ファイルを吐き出す。
`gcc -E`で`#include`などを展開する。（この際に、マクロも展開される）

`printf`などの実態は、`lib*.a`というものの中に存在する。そのため、`stdc++.h`にはない。


バイナリファイルには、オブジェクトファイルと実行可能ファイルに大別される。

MacOSの場合は、動的リンクしかさせてくれない。

昔は、静的リンクだったが、現在では動的リンクが主流
それぞれのプログラムのなかに、`printf`がたくさんあると、メモリに`printf`の実態がたくさんコピーされる。これによって、メモリ消費量がとても増える。

動的リンクの時は、`a.out`になっても、どのライブラリを使うか、という情報を付加するだけで、静的リンクのようなことはしないので、実行可能ファイルが軽量

動的リンクは、軽量になるだけでなく、高速になる。

- Cスタートアップルーチン
`return`文をアセンブリコードのなかに書かないと、return文の下を機械語と解釈してどんどん実行されてしまう。

Segmentation faultとか、bus errorとかは、エラーがでているだけマシ

AtCoderでもあるけど、どこで変なアクセスが起きていることの方がよっぽど怖い。

- `x86-64`

別名として`x64`, `x86_64`


- 著作物

授業で使用する場合は、著作権法の適応外になるが、基本は簡単に引用してはいけない

- 参考資料

`x86-64`のインテルのマニュアルは、英語だけでなく日本語でもマニュアルがあるので要チェック

x86アセンブラ入門（書籍）は、すべての命令が書かれている本（上のインテルの内容のほうがよい）

## 2 intro2

授業で今後扱うものを大雑把に扱うイントロダクション

アセンブリ言語は、C/C++のように改行等に縛りがない言語ではない。

`.text`: 以下に書かれているものをテキストセクションに出力してくれというもの（これはアセンブラが処理する）

`_add5:`: ラベル バイナリフィアルとしてで実行されるときに、具体的な番地の値になるが、この`_add5:`が具体的な値に置き換わる。

`x86-64`においては、コメントの開始は`#`で始まる。


再帰関数で、1回関数を呼ぶと、スタックフレームと呼ばれる関数呼び出し1回分のデータ

### アセンブリ言語上でのプッシュ操作

`%rsp` : sp = stack pointer これは、スタックトップを指す

`pushq $rax`をすると、スタックトップに`%rax`をプッシュする

### `add5.s`

`$`は定数（即値） imidiate value(imm) 

`.global _add5` 他の場所からも参照できるように

`addq $5, %rdi` = `%rdi += 5`

引数はレジスタで渡すという習慣がある。
返値は、`%rax`から`return`するというお約束があるので、`%rax`にする。

`%rip`: プログラムカウンタ 次に実行する場所を記憶している。

関数内部での`return`は、関数を呼び出した場所に戻るためのアドレスを読み込むということ？

`%rbp` base pointer

### コメント

アーキテクチャによってコメント開始記号はことなる。

```
#if 0

#endif
```

これを用いると、コンパイルする箇所を変動させる。

### 機械語命令

アセンブラ命令: アセンブラが実行するもの  
CPUが直接実行できるのは2進数の機械語だけ

### オペコードとオペランド

この授業で用いるGNUアセンブラはAT&T形式を使用。同じx86-64のアーキテクチャなのにも関わらず、代入の向きが逆である

### 機械語命令の主な種類

`lea`: load effective address

特権命令: OSを作るときに必要なもの(OSの内部的な動作を制御するとき, 入出力装置を制御するときにも`in`命令, `out`命令を使う。)

### コンピュータの基本構造

CPU: 制御装置(機械語命令を処理して、次の命令をフェッチしてくる)

ALU: 演算装置(四則演算を行う)

レジスタ: （変数とかを保持している。高速にアクセスできるが、小さい）

メインメモリ: 

(細かいことは、計算機アーキテクチャで)

### アセンブラ命令(assembler directive)

アセンブラ命令は、アセンブラが実行するもの   
機械語命令は、CPUが実行する

GNUアセンブラの場合は必ず、`.`で始まる。
アセンブル時、すなわち`add5.s`->`add5.o`にアセンブルするとき

`.text` ここから以下は、テキストセクションにしてくださいね。ということ


### アセンブラの主な仕事

2進数データをセクション毎に順番に出力

  `.text`: テキストセクション 機械語命令を格納

  `.data`: データセクション 初期値を格納している大域変数

ロケーションカウンタ(LC) 

　　各セクションごとに、どこまでデータがあるかということを覚えておくカウンタが必要になる。

ラベル

 　記号表を作り、ラベルをアドレスに変換する。
　　xという

`nm a.out`コマンド

### アセンブラ命令の主な種類

アラインメント調整: CPUが求めてくる要求に対して、その要求を満たすために、ロケーションカウンタの値を最小限増やしたりすることが必要。

アラインメント：　特定のアドレスに出力するためにロケーションカウンタを増やすこと


アセンブラが自動的にラベルをアドレスに変換する。（実態はアドレスだけど、アセンブラが実行時に置き換えてくれる。）

識別子(indentifier): 変数名、関数名を一意に識別するために使う


## 3-data

### ワード、ロング、クアッド

C言語は、`int`, `long`, `short`のサイズが決まっていない。

16進数や8進数に変換することや、16進数のデータを直読みする経験もいいよ！！

`bc`コマンドの`ibase`のデフォルト値は10なので、10進数から変換する時は指定する必要はない

また、`obase`から入力すること、なぜならば、`ibase`を先に指定してしまうと、入力する数値もそのn進数で入力する必要性が生じてしまうので

### 制御文字 Contorol Character

文字コードには、文字として表示できるものと、できないものの２つがある。（^J : 改行）
(ターミナルに、改行をしたいときは `Cotrol + J` でできる。)

エスケープシークエンス`^[`は、文字集合を切り替えるときに用いられたりする。
(`^I`: Tabが入る )

### C言語の`int`型のサイズ

これは、あえて決めていない。なぜなら、それぞれの処理系によって得意な数値のサイズが異なるので。

アセンブリ言語の授業では`moveq`命令が8ビット移動だったりするので、長さは決まっていた方がよい。

2進数として処理するときでも、符号ありか符号なしかの区別はしっかりとつけておくこと。

いつも0,1を反転して、１の補数(=足してすべて１になるものを呼ぶ。まぁこれは慣用句だからね...)を求めて、１を足すことで(Least Signifiicant Bit)、２の補数を求めていたが、それ以外の方法としては$2^n$に足してなると考えると、10進数に直した際にとても考えやすい。

`x86-64`は、２進数の計算の時は、とくにsigned, unsignedなのかを判別していない。あとでそれを処理する。

スライド32にあるように、符号あり整数ではオーバーフローとキャリーにはなんの関係もない。

### ゼロ拡張　符号拡張

ゼロ拡張については、各自やること

符号なしの場合は、0拡張は何の問題も生じないが、もし符号ありの場合は、負の数が正の数になってしまうのでまずい。
符号拡張のときは、0拡張の問題点を補うために、その対象の数が負の数なのか、正の数なのかによって0で埋めるのか、1で埋めるのかを判別する.

`movzlq`: z: ゼロのこと   
`movslq`: s: signed 符号拡張のこと

Googleで検索したときに、AT&TとIntelなのかは注意。ニモニックすらことなることが多いので

`切り捨て`については注意！！   
正負が変わってしまうこともある。
