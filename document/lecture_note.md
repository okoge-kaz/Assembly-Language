# アセンブリ言語

[参考資料](https://www.sigbus.info/compilerbook)

移植性(protability): アセンブリ言語は移植性が低いのが特徴

macOS 環境であればとてもよい

環境は macOS gcc(clang) (デバッガ: lldb)

`movq %rsp, %rbp` は、ニモニック(mnemonic)

`_add5:` は、ラベル

## コンパイル、アセンブル

アセンブラ命令でいらない（すくなくとも今回の授業ではいらないものがあるので`-fno-asynchronous-unwind-tables -fno-verboseasm`をコンパイルオプションを書く）

`add5.o`は、バイナリファイルなので`less`コマンドでは見れない、よって`od -A d -t x1 add5.o `のように`od`コマンドで 16 進ダンプする必要がある

## ２進数

２進数だけでは、文字なのか機械語命令なのかわからない。これは外部から与えられる。

機械語コード＝プログラムのこと

`od`コマンド : 名前の由来は octual dump

16 進ダンプ = バイナリデータを１バイト毎に 16 進数で表示すること

- 逆アセンブル

```
objdump -d add5.o

add5.o: file format mach-o 64-bit x86-64


Disassembly of section __TEXT,__text:

0000000000000000 <_add5>:
       0: 55                            pushq   %rbp
       1: 48 89 e5                      movq    %rsp, %rbp
       4: 48 89 7d f8                   movq    %rdi, -8(%rbp)
       8: 48 8b 45 f8                   movq    -8(%rbp), %rax
       c: 48 83 c0 05                   addq    $5, %rax
      10: 5d                            popq    %rbp
      11: c3                            retq

```

テキストセクションの先頭からのバイト数が左側に書かれる。

x86-64 の命令は、命令によって長さがバラバラ（可変長）

## ABI API

- コーリングコンベンション ( = 関数呼び出し規約)

ABI は、バイナリファイルを再コンパイルなしに実行できる

API は、ソースコードのためのインタフェース

再コンパイルすれば同じソースコードを実行できる。

## `add5.s`早わかり

`.text` などの`.`で始まるのはアセンブラ命令

ドル記号$ は定数（即値）

% パーセント記号は、レジスタ

コロン記号 : で終わるのはラベル

naive: 素朴な愚直な という意味でコンピューターサイエンスでは用いる。

C/C++からアセンブリ言語にコンパイルするときは、さまざまなアセンブリ言語の書き方が考えられるが、アセンブルするときに実行ファイルになるときはほぼ一意に決まる。

モジュール分割が不適切だと、保守性が悪化する。よくある例だと、修正するのに同じようなプログラミングを修正する羽目になる。

プログラムを作るときは、なんとなくの予想に基づいてモジュール分割を行うが往々にして、あとで見直す羽目になる。

- バイナリ形式
  スライドに存在するような様々なバイナリ形式すべてに対して使うことが可能

- tarage(ターゲット)
  どうして、プログラムを実行するプラットフォームが重要か？というと、プログラムを作成する OS とそれを実行する OS が異なることは往々にしてあるから（＝クロスコンパイル）

例. ios アプリケーション

- リンク
  複数のオブジェクトファイルをリンクして実行可能ファイルを吐き出す。
  `gcc -E`で`#include`などを展開する。（この際に、マクロも展開される）

`printf`などの実態は、`lib*.a`というものの中に存在する。そのため、`stdc++.h`にはない。

バイナリファイルには、オブジェクトファイルと実行可能ファイルに大別される。

MacOS の場合は、動的リンクしかさせてくれない。

昔は、静的リンクだったが、現在では動的リンクが主流
それぞれのプログラムのなかに、`printf`がたくさんあると、メモリに`printf`の実態がたくさんコピーされる。これによって、メモリ消費量がとても増える。

動的リンクの時は、`a.out`になっても、どのライブラリを使うか、という情報を付加するだけで、静的リンクのようなことはしないので、実行可能ファイルが軽量

動的リンクは、軽量になるだけでなく、高速になる。

- C スタートアップルーチン
  `return`文をアセンブリコードのなかに書かないと、return 文の下を機械語と解釈してどんどん実行されてしまう。

Segmentation fault とか、bus error とかは、エラーがでているだけマシ

AtCoder でもあるけど、どこで変なアクセスが起きていることの方がよっぽど怖い。

- `x86-64`

別名として`x64`, `x86_64`

- 著作物

授業で使用する場合は、著作権法の適応外になるが、基本は簡単に引用してはいけない

- 参考資料

`x86-64`のインテルのマニュアルは、英語だけでなく日本語でもマニュアルがあるので要チェック

x86 アセンブラ入門（書籍）は、すべての命令が書かれている本（上のインテルの内容のほうがよい）

## 2 intro2

授業で今後扱うものを大雑把に扱うイントロダクション

アセンブリ言語は、C/C++のように改行等に縛りがない言語ではない。

`.text`: 以下に書かれているものをテキストセクションに出力してくれというもの（これはアセンブラが処理する）

`_add5:`: ラベル バイナリフィアルとしてで実行されるときに、具体的な番地の値になるが、この`_add5:`が具体的な値に置き換わる。

`x86-64`においては、コメントの開始は`#`で始まる。

再帰関数で、1 回関数を呼ぶと、スタックフレームと呼ばれる関数呼び出し 1 回分のデータ

### アセンブリ言語上でのプッシュ操作

`%rsp` : sp = stack pointer これは、スタックトップを指す

`pushq $rax`をすると、スタックトップに`%rax`をプッシュする

### `add5.s`

`$`は定数（即値） imidiate value(imm)

`.global _add5` 他の場所からも参照できるように

`addq $5, %rdi` = `%rdi += 5`

引数はレジスタで渡すという習慣がある。
返値は、`%rax`から`return`するというお約束があるので、`%rax`にする。

`%rip`: プログラムカウンタ 次に実行する場所を記憶している。

関数内部での`return`は、関数を呼び出した場所に戻るためのアドレスを読み込むということ？

`%rbp` base pointer

### コメント

アーキテクチャによってコメント開始記号はことなる。

```
#if 0

#endif
```

これを用いると、コンパイルする箇所を変動させる。

### 機械語命令

アセンブラ命令: アセンブラが実行するもの  
CPU が直接実行できるのは 2 進数の機械語だけ

### オペコードとオペランド

この授業で用いる GNU アセンブラは AT&T 形式を使用。同じ x86-64 のアーキテクチャなのにも関わらず、代入の向きが逆である

### 機械語命令の主な種類

`lea`: load effective address

特権命令: OS を作るときに必要なもの(OS の内部的な動作を制御するとき, 入出力装置を制御するときにも`in`命令, `out`命令を使う。)

### コンピュータの基本構造

CPU: 制御装置(機械語命令を処理して、次の命令をフェッチしてくる)

ALU: 演算装置(四則演算を行う)

レジスタ: （変数とかを保持している。高速にアクセスできるが、小さい）

メインメモリ:

(細かいことは、計算機アーキテクチャで)

### アセンブラ命令(assembler directive)

アセンブラ命令は、アセンブラが実行するもの  
機械語命令は、CPU が実行する

GNU アセンブラの場合は必ず、`.`で始まる。
アセンブル時、すなわち`add5.s`->`add5.o`にアセンブルするとき

`.text` ここから以下は、テキストセクションにしてくださいね。ということ

### アセンブラの主な仕事

2 進数データをセクション毎に順番に出力

`.text`: テキストセクション 機械語命令を格納

`.data`: データセクション 初期値を格納している大域変数

ロケーションカウンタ(LC)

各セクションごとに、どこまでデータがあるかということを覚えておくカウンタが必要になる。

ラベル

記号表を作り、ラベルをアドレスに変換する。
x という

`nm a.out`コマンド

### アセンブラ命令の主な種類

アラインメント調整: CPU が求めてくる要求に対して、その要求を満たすために、ロケーションカウンタの値を最小限増やしたりすることが必要。

アラインメント： 特定のアドレスに出力するためにロケーションカウンタを増やすこと

アセンブラが自動的にラベルをアドレスに変換する。（実態はアドレスだけど、アセンブラが実行時に置き換えてくれる。）

識別子(indentifier): 変数名、関数名を一意に識別するために使う

## 3-data

### ワード、ロング、クアッド

C 言語は、`int`, `long`, `short`のサイズが決まっていない。

16 進数や 8 進数に変換することや、16 進数のデータを直読みする経験もいいよ！！

`bc`コマンドの`ibase`のデフォルト値は 10 なので、10 進数から変換する時は指定する必要はない

また、`obase`から入力すること、なぜならば、`ibase`を先に指定してしまうと、入力する数値もその n 進数で入力する必要性が生じてしまうので

### 制御文字 Contorol Character

文字コードには、文字として表示できるものと、できないものの２つがある。（^J : 改行）
(ターミナルに、改行をしたいときは `Cotrol + J` でできる。)

エスケープシークエンス`^[`は、文字集合を切り替えるときに用いられたりする。
(`^I`: Tab が入る )

### C 言語の`int`型のサイズ

これは、あえて決めていない。なぜなら、それぞれの処理系によって得意な数値のサイズが異なるので。

アセンブリ言語の授業では`moveq`命令が 8 ビット移動だったりするので、長さは決まっていた方がよい。

2 進数として処理するときでも、符号ありか符号なしかの区別はしっかりとつけておくこと。

いつも 0,1 を反転して、１の補数(=足してすべて１になるものを呼ぶ。まぁこれは慣用句だからね...)を求めて、１を足すことで(Least Signifiicant Bit)、２の補数を求めていたが、それ以外の方法としては$2^n$に足してなると考えると、10 進数に直した際にとても考えやすい。

`x86-64`は、２進数の計算の時は、とくに signed, unsigned なのかを判別していない。あとでそれを処理する。

スライド 32 にあるように、符号あり整数ではオーバーフローとキャリーにはなんの関係もない。

### ゼロ拡張　符号拡張

ゼロ拡張については、各自やること

符号なしの場合は、0 拡張は何の問題も生じないが、もし符号ありの場合は、負の数が正の数になってしまうのでまずい。
符号拡張のときは、0 拡張の問題点を補うために、その対象の数が負の数なのか、正の数なのかによって 0 で埋めるのか、1 で埋めるのかを判別する.

`movzlq`: z: ゼロのこと  
`movslq`: s: signed 符号拡張のこと

Google で検索したときに、AT&T と Intel なのかは注意。ニモニックすらことなることが多いので

`切り捨て`については注意！！  
正負が変わってしまうこともある。

### アラインメント

アラインメント制約は、Application Binary Interfaceの都合によるもの  
アラインメントを守らないと、実行時エラーが起きることはないが、実行時間がとても長くなる等のことが起きる

2.pdfでやったように、アラインメントをとるということは、アセンブラがローケーションカウンタを調整するというっこと。

`p2aling 4`:  16の倍数のアドレスに配置する

アラインメント制約を満たしているようにpaddingをとる。　　
C言語の構造体はパディングが入るが、配列の場合はpaddingは入らない。

構造体のメンバ変数だけをみて、使用するバイト数を見積もることはできない。

p51 のスライドにあるように、構造体は配列使用することを想定して、最後に余分なpaddingをいれることがある。


## 4-arch

### メモリ

Random Access Memory

テープデバイスであると、読みにいくところによって時間が変わる。random accessというのはすごいこと

バイトアドレシング：1バイトごとに一意に識別できる

アドレス空間というのは、理論上あるアドレスであって、必ずしも本当にそんなアドレスがあるとは限らない。

定数の場合は、$1000となる。

レジタスタも機械語命令上では、２進数で管理されるが、基本的にプログラマがアクセスするのは、`%rax`のように文字でアクセスする。

スタックポインタやベースポインタは、基本的に自由には使ってはいけない。
また、割り算などは、どこのレジスタに配置するべきなのどの制約がある。


### 汎用レジスタ

汎用レジスタに別名があって細かい区分があるのは、歴史的にそのサイズが主流だったころのことを引きずっている。

`gcc -g `オプションによって実行可能ファイルに余計な情報がくっつく

`si`: ステップインストラクション

### ステータスレジスタ

ステータスレジスタにおける、セット(= 1をつける), クリア(= 0)

`jg`: jup if greater

条件付きジャンプ命令は、符号ありのときと、符号なしのときで使う命令も異なる。

`ZF == 0 && SF == OF`

zero flagは0（ない）のは、

特権命令はOSしかできない。アセンブリ言語で、入出力システムを動かすものを書いても、OS以外は、I/Oには触らせてもらえない。

基本的には、自分のプロセス以外のメモリを読むことはできない。
昔々は、自分が書いたプログラムがカーネルごと吹っ飛ばすようなことがあった。

リアルモード: なんでも書き換えができてしまう。

- フラットモデル

フラットモデルではない昔のときは、どれだけズレるのかで指定していたので、かならずしも、同じ値だからといって同じ場所を指しているとは限らない

仮想アドレス（これちゃんと理解しないと...）

C言語とか直接ハードコーディングで、アドレスを指定することができるが、大抵はsegmentation faultで失敗する。これは、OSからもらったメモリだけを使用するという原則? に反する。

そろそろ、しっかりと復習する必要がありそう...

